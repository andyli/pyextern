/* This file is generated, do not edit! */
package keras.models;
@:pythonImport("keras.models") extern class Models_Module {
	/**
		`Input()` is used to instantiate a Keras tensor.
		
		A Keras tensor is a tensor object from the underlying backend
		(Theano, TensorFlow or CNTK), which we augment with certain
		attributes that allow us to build a Keras model
		just by knowing the inputs and outputs of the model.
		
		For instance, if a, b and c are Keras tensors,
		it becomes possible to do:
		`model = Model(input=[a, b], output=c)`
		
		The added Keras attributes are:
		    `_keras_shape`: Integer shape tuple propagated
		        via Keras-side shape inference.
		    `_keras_history`: Last layer applied to the tensor.
		        the entire layer graph is retrievable from that layer,
		        recursively.
		
		# Arguments
		    shape: A shape tuple (integer), not including the batch size.
		        For instance, `shape=(32,)` indicates that the expected input
		        will be batches of 32-dimensional vectors.
		    batch_shape: A shape tuple (integer), including the batch size.
		        For instance, `batch_shape=(10, 32)` indicates that
		        the expected input will be batches of 10 32-dimensional vectors.
		        `batch_shape=(None, 32)` indicates batches of an arbitrary number
		        of 32-dimensional vectors.
		    name: An optional name string for the layer.
		        Should be unique in a model (do not reuse the same name twice).
		        It will be autogenerated if it isn't provided.
		    dtype: The data type expected by the input, as a string
		        (`float32`, `float64`, `int32`...)
		    sparse: A boolean specifying whether the placeholder
		        to be created is sparse.
		    tensor: Optional existing tensor to wrap into the `Input` layer.
		        If set, the layer will not create a placeholder tensor.
		
		# Returns
		    A tensor.
		
		# Example
		
		```python
		# this is a logistic regression in Keras
		x = Input(shape=(32,))
		y = Dense(16, activation='softmax')(x)
		model = Model(x, y)
		```
	**/
	static public function Input(?shape:Dynamic, ?batch_shape:Dynamic, ?name:Dynamic, ?dtype:Dynamic, ?sparse:Dynamic, ?tensor:Dynamic):Dynamic;
	static public var __builtins__ : Dynamic;
	static public var __cached__ : Dynamic;
	static public var __doc__ : Dynamic;
	static public var __file__ : Dynamic;
	static public var __loader__ : Dynamic;
	static public var __name__ : Dynamic;
	static public var __package__ : Dynamic;
	static public var __spec__ : Dynamic;
	/**
		Clone a functional `Model` instance.
		
		Model cloning is similar to calling a model on new inputs,
		except that it creates new layers (and thus new weights) instead
		of sharing the weights of the existing layers.
		
		# Arguments
		    model: Instance of `Model`.
		    input_tensors: optional list of input tensors
		        to build the model upon. If not provided,
		        placeholders will be created.
		
		# Returns
		    An instance of `Model` reproducing the behavior
		    of the original model, on top of new inputs tensors,
		    using newly instantiated weights.
		
		# Raises
		    ValueError: in case of invalid `model` argument value.
	**/
	static public function _clone_functional_model(model:Dynamic, ?input_tensors:Dynamic):Dynamic;
	/**
		Clone a `Sequential` model instance.
		
		Model cloning is similar to calling a model on new inputs,
		except that it creates new layers (and thus new weights) instead
		of sharing the weights of the existing layers.
		
		# Arguments
		    model: Instance of `Sequential`.
		    input_tensors: optional list of input tensors
		        to build the model upon. If not provided,
		        placeholders will be created.
		
		# Returns
		    An instance of `Sequential` reproducing the behavior
		    of the original model, on top of new inputs tensors,
		    using newly instantiated weights.
		
		# Raises
		    ValueError: in case of invalid `model` argument value.
	**/
	static public function _clone_sequential_model(model:Dynamic, ?input_tensors:Dynamic):Dynamic;
	static public var absolute_import : Dynamic;
	/**
		Clone any `Model` instance.
		
		Model cloning is similar to calling a model on new inputs,
		except that it creates new layers (and thus new weights) instead
		of sharing the weights of the existing layers.
		
		# Arguments
		    model: Instance of `Model`
		        (could be a functional model or a Sequential model).
		    input_tensors: optional list of input tensors
		        to build the model upon. If not provided,
		        placeholders will be created.
		
		# Returns
		    An instance of `Model` reproducing the behavior
		    of the original model, on top of new inputs tensors,
		    using newly instantiated weights.
		
		# Raises
		    ValueError: in case of invalid `model` argument value.
	**/
	static public function clone_model(model:Dynamic, ?input_tensors:Dynamic):Dynamic;
	static public var division : Dynamic;
	/**
		Checks if a callable accepts a given keyword argument.
		
		For Python 2, checks if there is an argument with the given name.
		
		For Python 3, checks if there is an argument with the given name, and
		also whether this argument can be called with a keyword (i.e. if it is
		not a positional-only argument).
		
		# Arguments
		    fn: Callable to inspect.
		    name: Check if `fn` can be called with `name` as a keyword argument.
		    accept_all: What to return if there is no parameter called `name`
		                but the function accepts a `**kwargs` argument.
		
		# Returns
		    bool, whether `fn` accepts a `name` keyword argument.
	**/
	static public function has_arg(fn:Dynamic, name:Dynamic, ?accept_all:Dynamic):Dynamic;
	/**
		Loads a model saved via `save_model`.
		
		# Arguments
		    filepath: one of the following:
		        - string, path to the saved model, or
		        - h5py.File or h5py.Group object from which to load the model
		    custom_objects: Optional dictionary mapping names
		        (strings) to custom classes or functions to be
		        considered during deserialization.
		    compile: Boolean, whether to compile the model
		        after loading.
		
		# Returns
		    A Keras model instance. If an optimizer was found
		    as part of the saved model, the model is already
		    compiled. Otherwise, the model is uncompiled and
		    a warning will be displayed. When `compile` is set
		    to False, the compilation is omitted without any
		    warning.
		
		# Raises
		    ImportError: if h5py is not available.
		    ValueError: In case of an invalid savefile.
	**/
	static public function load_model(filepath:Dynamic, ?custom_objects:Dynamic, ?compile:Dynamic):Dynamic;
	/**
		Instantiates a Keras model from its config.
		
		# Arguments
		    config: Configuration dictionary.
		    custom_objects: Optional dictionary mapping names
		        (strings) to custom classes or functions to be
		        considered during deserialization.
		
		# Returns
		    A Keras model instance (uncompiled).
		
		# Raises
		    TypeError: if `config` is not a dictionary.
	**/
	static public function model_from_config(config:Dynamic, ?custom_objects:Dynamic):Dynamic;
	/**
		Parses a JSON model configuration file and returns a model instance.
		
		# Arguments
		    json_string: JSON string encoding a model configuration.
		    custom_objects: Optional dictionary mapping names
		        (strings) to custom classes or functions to be
		        considered during deserialization.
		
		# Returns
		    A Keras model instance (uncompiled).
	**/
	static public function model_from_json(json_string:Dynamic, ?custom_objects:Dynamic):Dynamic;
	/**
		Parses a yaml model configuration file and returns a model instance.
		
		# Arguments
		    yaml_string: YAML string encoding a model configuration.
		    custom_objects: Optional dictionary mapping names
		        (strings) to custom classes or functions to be
		        considered during deserialization.
		
		# Returns
		    A Keras model instance (uncompiled).
	**/
	static public function model_from_yaml(yaml_string:Dynamic, ?custom_objects:Dynamic):Dynamic;
	static public var print_function : Dynamic;
	/**
		Save a model to a HDF5 file.
		
		Note: Please also see
		[How can I install HDF5 or h5py to save my models in Keras?](
		    /getting-started/faq/
		    #how-can-i-install-HDF5-or-h5py-to-save-my-models-in-Keras)
		in the FAQ for instructions on how to install `h5py`.
		
		The saved model contains:
		    - the model's configuration (topology)
		    - the model's weights
		    - the model's optimizer's state (if any)
		
		Thus the saved model can be reinstantiated in
		the exact same state, without any of the code
		used for model definition or training.
		
		# Arguments
		    model: Keras model instance to be saved.
		    filepath: one of the following:
		        - string, path where to save the model, or
		        - h5py.File or h5py.Group object where to save the model
		    overwrite: Whether we should overwrite any existing
		        model at the target location, or instead
		        ask the user with a manual prompt.
		    include_optimizer: If True, save optimizer's state together.
		
		# Raises
		    ImportError: if h5py is not available.
	**/
	static public function save_model(model:Dynamic, filepath:Dynamic, ?overwrite:Dynamic, ?include_optimizer:Dynamic):Dynamic;
	/**
		Normalizes a list/tensor into a list.
		
		If a tensor is passed, we return
		a list of size 1 containing the tensor.
		
		# Arguments
		    x: target object to be normalized.
		    allow_tuple: If False and x is a tuple,
		        it will be converted into a list
		        with a single element (the tuple).
		        Else converts the tuple to a list.
		
		# Returns
		    A list.
	**/
	static public function to_list(x:Dynamic, ?allow_tuple:Dynamic):Dynamic;
}