/* This file is generated, do not edit! */
package tensorflow.python.framework.auto_control_deps;
@:pythonImport("tensorflow.python.framework.auto_control_deps") extern class Auto_control_deps_Module {
	static public var ASYNC_STATEFUL_OPS : Dynamic;
	static public var LEGACY_RANDOM_OPS : Dynamic;
	static public var _ALLOWLIST_STATELESS_OPS : Dynamic;
	static public var _ALL_DENYLISTED_OPS : Dynamic;
	static public var _ORDER_INSENSITIVE_STATEFUL_OPS : Dynamic;
	static public var __builtins__ : Dynamic;
	static public var __cached__ : Dynamic;
	static public var __doc__ : Dynamic;
	static public var __file__ : Dynamic;
	static public var __loader__ : Dynamic;
	static public var __name__ : Dynamic;
	static public var __package__ : Dynamic;
	static public var __spec__ : Dynamic;
	static public var _acd_resource_resolvers_registry : Dynamic;
	/**
		Returns an iterable of resources touched by this `op`.
	**/
	static public function _get_resource_inputs(op:Dynamic):Dynamic;
	static public var absolute_import : Dynamic;
	/**
		Wraps f to automatically insert control dependencies.
		
		The inserted dependencies ensure that:
		  1. All stateful ops in f run when the result of f runs
		  2. Updates to the same resources happen in order.
		
		Args:
		  f: the function to be wrapped.
		
		Returns:
		  The wrapped function.
	**/
	static public function automatic_control_dependencies(f:Dynamic):Dynamic;
	/**
		Returns CollectiveManager ID from the op if one exists, else None.
		
		CollectiveManager adds collective and no_op operations tagged with an ID,
		unique to the manager object. This function extracts that ID, or None, if the
		node was not generated by a CollectiveManager.
		
		Args:
		  op: `Operation` to get the collective manager ID from.
		
		Returns:
		  List of CollectiveManager IDs used by the op.
	**/
	static public function collective_manager_ids_from_op(op:Dynamic):Dynamic;
	static public var division : Dynamic;
	static public function op_is_stateful(op:Dynamic):Dynamic;
	static public var print_function : Dynamic;
	/**
		Register a function for resolving resources touched by an op.
		
		`f` is called for every Operation added in the ACD context with the op's
		original resource reads and writes. `f` is expected to update the sets of
		resource reads and writes in-place and return True if it updated either of the
		sets, False otherwise.
		
		Example:
		@register_acd_resource_resolver
		def ResolveIdentity(op, resource_reads, resource_writes):
		  # op: The `Operation` being processed by ACD currently.
		  # resource_reads: An `ObjectIdentitySet` of read-only resources.
		  # resource_writes: An `ObjectIdentitySet` of read-write resources.
		  if not resource_reads or resource_writes:
		    return False
		  def update(resource_inputs):
		    to_add = []
		    to_remove = []
		    for t in resource_inputs:
		      if t.op.type == "Identity":
		        to_remove.append(t)
		        to_add.append(t.op.inputs[0])
		    if not to_add and not to_remove:
		      return False
		    for t in to_remove:
		      resource_inputs.discard(t)
		    resource_inputs.update(to_add)
		    return True
		  return update(resource_reads) or update(resource_writes)
		
		Args:
		  f: Python function with signature
		  (Operation, ObjectIdentitySet, ObjectIdentitySet) -> bool
		
		Returns:
		  The function `f` after adding it to the registry.
	**/
	static public function register_acd_resource_resolver(f:Dynamic):Dynamic;
}