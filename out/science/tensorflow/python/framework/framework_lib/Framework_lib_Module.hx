/* This file is generated, do not edit! */
package tensorflow.python.framework.framework_lib;
@:pythonImport("tensorflow.python.framework.framework_lib") extern class Framework_lib_Module {
	/**
		Specifies that ops of type `op_type` is not differentiable.
		
		This function should *not* be used for operations that have a
		well-defined gradient that is not yet implemented.
		
		This function is only used when defining a new op type. It may be
		used for ops such as `tf.size()` that are not differentiable.  For
		example:
		
		```python
		tf.no_gradient("Size")
		```
		
		The gradient computed for 'op_type' will then propagate zeros.
		
		For ops that have a well-defined gradient but are not yet implemented,
		no declaration should be made, and an error *must* be thrown if
		an attempt to request its gradient is made.
		
		Args:
		  op_type: The string type of an operation. This corresponds to the
		    `OpDef.name` field for the proto that defines the operation.
		
		Raises:
		  TypeError: If `op_type` is not a string.
	**/
	static public function NoGradient(op_type:Dynamic):Dynamic;
	/**
		Specifies that ops of type `op_type` is not differentiable.
		
		This function should *not* be used for operations that have a
		well-defined gradient that is not yet implemented.
		
		This function is only used when defining a new op type. It may be
		used for ops such as `tf.size()` that are not differentiable.  For
		example:
		
		```python
		tf.no_gradient("Size")
		```
		
		The gradient computed for 'op_type' will then propagate zeros.
		
		For ops that have a well-defined gradient but are not yet implemented,
		no declaration should be made, and an error *must* be thrown if
		an attempt to request its gradient is made.
		
		Args:
		  op_type: The string type of an operation. This corresponds to the
		    `OpDef.name` field for the proto that defines the operation.
		
		Raises:
		  TypeError: If `op_type` is not a string.
	**/
	static public function NotDifferentiable(op_type:Dynamic):Dynamic;
	static public var QUANTIZED_DTYPES : Dynamic;
	static public var TF_VALUE_DTYPES : Dynamic;
	static public var __builtins__ : Dynamic;
	static public var __cached__ : Dynamic;
	static public var __doc__ : Dynamic;
	static public var __file__ : Dynamic;
	static public var __loader__ : Dynamic;
	static public var __name__ : Dynamic;
	static public var __package__ : Dynamic;
	static public var __spec__ : Dynamic;
	static public var absolute_import : Dynamic;
	/**
		Wrapper for `Graph.add_to_collection()` using the default graph.
		
		See `tf.Graph.add_to_collection`
		for more details.
		
		Args:
		  name: The key for the collection. For example, the `GraphKeys` class
		    contains many standard names for collections.
		  value: The value to add to the collection.
		
		@compatibility(eager)
		Collections are only supported in eager when variables are created inside
		an EagerVariableStore (e.g. as part of a layer or template).
		@end_compatibility
	**/
	static public function add_to_collection(name:Dynamic, value:Dynamic):Dynamic;
	/**
		Wrapper for `Graph.add_to_collections()` using the default graph.
		
		See `tf.Graph.add_to_collections`
		for more details.
		
		Args:
		  names: The key for the collections. The `GraphKeys` class contains many
		    standard names for collections.
		  value: The value to add to the collections.
		
		@compatibility(eager)
		Collections are only supported in eager when variables are created inside
		an EagerVariableStore (e.g. as part of a layer or template).
		@end_compatibility
	**/
	static public function add_to_collections(names:Dynamic, value:Dynamic):Dynamic;
	/**
		Converts the given `type_value` to a `DType`.
		
		Note: `DType` values are interned. When passed a new `DType` object,
		`as_dtype` always returns the interned value.
		
		Args:
		  type_value: A value that can be converted to a `tf.DType` object. This may
		    currently be a `tf.DType` object, a [`DataType`
		    enum](https://www.tensorflow.org/code/tensorflow/core/framework/types.proto),
		      a string type name, or a [`numpy.dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html).
		
		Returns:
		  A `DType` corresponding to `type_value`.
		
		Raises:
		  TypeError: If `type_value` cannot be converted to a `DType`.
	**/
	static public function as_dtype(type_value:Dynamic):Dynamic;
	static public var bfloat16 : Dynamic;
	static public var bfloat16_ref : Dynamic;
	static public var bool : Dynamic;
	static public var bool_ref : Dynamic;
	static public function colocate_with(op:Dynamic, ?ignore_existing:Dynamic):Dynamic;
	static public var complex128 : Dynamic;
	static public var complex128_ref : Dynamic;
	static public var complex64 : Dynamic;
	static public var complex64_ref : Dynamic;
	/**
		Wrapper for `Graph.container()` using the default graph.
		
		Args:
		  container_name: The container string to use in the context.
		
		Returns:
		  A context manager that specifies the default container to use for newly
		  created stateful ops.
	**/
	static public function container(container_name:Dynamic):Dynamic;
	/**
		Wrapper for `Graph.control_dependencies()` using the default graph.
		
		See `tf.Graph.control_dependencies` for more details.
		
		Note: *In TensorFlow 2 with eager and/or Autograph, you should not require
		this method, as ops execute in the expected order thanks to automatic control
		dependencies.* Only use `tf.control_dependencies` when working with v1
		`tf.Graph` code.
		
		When eager execution is enabled, any callable object in the `control_inputs`
		list will be called.
		
		Args:
		  control_inputs: A list of `Operation` or `Tensor` objects which must be
		    executed or computed before running the operations defined in the context.
		    Can also be `None` to clear the control dependencies. If eager execution
		    is enabled, any callable object in the `control_inputs` list will be
		    called.
		
		Returns:
		 A context manager that specifies control dependencies for all
		 operations constructed within the context.
	**/
	static public function control_dependencies(control_inputs:Dynamic):Dynamic;
	/**
		Implementation of the public convert_to_tensor.
	**/
	static public function convert_to_tensor(value:Dynamic, ?dtype:Dynamic, ?name:Dynamic, ?as_ref:Dynamic, ?preferred_dtype:Dynamic, ?dtype_hint:Dynamic, ?ctx:Dynamic, ?accepted_result_types:Dynamic):Dynamic;
	/**
		Converts the given object to a `Tensor` or an `IndexedSlices`.
		
		If `value` is an `IndexedSlices` or `SparseTensor` it is returned
		unmodified. Otherwise, it is converted to a `Tensor` using
		`convert_to_tensor()`.
		
		Args:
		  value: An `IndexedSlices`, `SparseTensor`, or an object that can be consumed
		    by `convert_to_tensor()`.
		  dtype: (Optional.) The required `DType` of the returned `Tensor` or
		    `IndexedSlices`.
		  name: (Optional.) A name to use if a new `Tensor` is created.
		
		Returns:
		  A `Tensor`, `IndexedSlices`, or `SparseTensor` based on `value`.
		
		Raises:
		  ValueError: If `dtype` does not match the element type of `value`.
	**/
	static public function convert_to_tensor_or_indexed_slices(value:Dynamic, ?dtype:Dynamic, ?name:Dynamic):Dynamic;
	/**
		Converts value to a `SparseTensor` or `Tensor`.
		
		Args:
		  value: A `SparseTensor`, `SparseTensorValue`, or an object whose type has a
		    registered `Tensor` conversion function.
		  dtype: Optional element type for the returned tensor. If missing, the type
		    is inferred from the type of `value`.
		  name: Optional name to use if a new `Tensor` is created.
		
		Returns:
		  A `SparseTensor` or `Tensor` based on `value`.
		
		Raises:
		  RuntimeError: If result type is incompatible with `dtype`.
	**/
	static public function convert_to_tensor_or_sparse_tensor(value:Dynamic, ?dtype:Dynamic, ?name:Dynamic):Dynamic;
	/**
		Wrapper for `Graph.device()` using the default graph.
		
		See `tf.Graph.device` for more details.
		
		Args:
		  device_name_or_function: The device name or function to use in the context.
		
		Returns:
		  A context manager that specifies the default device to use for newly
		  created ops.
		
		Raises:
		  RuntimeError: If eager execution is enabled and a function is passed in.
	**/
	static public function device(device_name_or_function:Dynamic):Dynamic;
	static public var division : Dynamic;
	static public var double : Dynamic;
	static public var double_ref : Dynamic;
	static public var dtype_range : Dynamic;
	static public var float16 : Dynamic;
	static public var float16_ref : Dynamic;
	static public var float32 : Dynamic;
	static public var float32_ref : Dynamic;
	static public var float64 : Dynamic;
	static public var float64_ref : Dynamic;
	/**
		Wrapper for `Graph.get_collection()` using the default graph.
		
		See `tf.Graph.get_collection`
		for more details.
		
		Args:
		  key: The key for the collection. For example, the `GraphKeys` class contains
		    many standard names for collections.
		  scope: (Optional.) If supplied, the resulting list is filtered to include
		    only items whose `name` attribute matches using `re.match`. Items without
		    a `name` attribute are never returned if a scope is supplied and the
		    choice or `re.match` means that a `scope` without special tokens filters
		    by prefix.
		
		Returns:
		  The list of values in the collection with the given `name`, or
		  an empty list if no value has been added to that collection. The
		  list contains the values in the order under which they were
		  collected.
		
		@compatibility(eager)
		Collections are not supported when eager execution is enabled.
		@end_compatibility
	**/
	static public function get_collection(key:Dynamic, ?scope:Dynamic):Dynamic;
	/**
		Wrapper for `Graph.get_collection_ref()` using the default graph.
		
		See `tf.Graph.get_collection_ref`
		for more details.
		
		Args:
		  key: The key for the collection. For example, the `GraphKeys` class contains
		    many standard names for collections.
		
		Returns:
		  The list of values in the collection with the given `name`, or an empty
		  list if no value has been added to that collection.  Note that this returns
		  the collection list itself, which can be modified in place to change the
		  collection.
		
		@compatibility(eager)
		Collections are not supported when eager execution is enabled.
		@end_compatibility
	**/
	static public function get_collection_ref(key:Dynamic):Dynamic;
	/**
		Returns the default graph for the current thread.
		
		The returned graph will be the innermost graph on which a
		`Graph.as_default()` context has been entered, or a global default
		graph if none has been explicitly created.
		
		NOTE: The default graph is a property of the current thread. If you
		create a new thread, and wish to use the default graph in that
		thread, you must explicitly add a `with g.as_default():` in that
		thread's function.
		
		@compatibility(TF2)
		`get_default_graph` does not work with either eager execution or
		`tf.function`, and you should not invoke it directly. To migrate code that
		uses Graph-related functions to TF2, rewrite the code without them. See the
		[migration guide](https://www.tensorflow.org/guide/migrate) for more
		description about the behavior and semantic changes between Tensorflow 1 and
		Tensorflow 2.
		@end_compatibility
		
		Returns:
		  The default `Graph` being used in the current thread.
	**/
	static public function get_default_graph():Dynamic;
	/**
		Returns the local seeds an operation should use given an op-specific seed.
		
		Given operation-specific seed, `op_seed`, this helper function returns two
		seeds derived from graph-level and op-level seeds. Many random operations
		internally use the two seeds to allow user to change the seed globally for a
		graph, or for only specific operations.
		
		For details on how the graph-level seed interacts with op seeds, see
		`tf.compat.v1.random.set_random_seed`.
		
		Args:
		  op_seed: integer.
		
		Returns:
		  A tuple of two integers that should be used for the local seed of this
		  operation.
	**/
	static public function get_seed(op_seed:Dynamic):Dynamic;
	static public var half : Dynamic;
	static public var half_ref : Dynamic;
	/**
		Imports the graph from `graph_def` into the current default `Graph`. (deprecated arguments)
		
		Warning: SOME ARGUMENTS ARE DEPRECATED: `(op_dict)`. They will be removed in a future version.
		Instructions for updating:
		Please file an issue at https://github.com/tensorflow/tensorflow/issues if you depend on this feature.
		
		This function provides a way to import a serialized TensorFlow
		[`GraphDef`](https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto)
		protocol buffer, and extract individual objects in the `GraphDef` as
		`tf.Tensor` and `tf.Operation` objects. Once extracted,
		these objects are placed into the current default `Graph`. See
		`tf.Graph.as_graph_def` for a way to create a `GraphDef`
		proto.
		
		Args:
		  graph_def: A `GraphDef` proto containing operations to be imported into
		    the default graph.
		  input_map: A dictionary mapping input names (as strings) in `graph_def`
		    to `Tensor` objects. The values of the named input tensors in the
		    imported graph will be re-mapped to the respective `Tensor` values.
		  return_elements: A list of strings containing operation names in
		    `graph_def` that will be returned as `Operation` objects; and/or
		    tensor names in `graph_def` that will be returned as `Tensor` objects.
		  name: (Optional.) A prefix that will be prepended to the names in
		    `graph_def`. Note that this does not apply to imported function names.
		    Defaults to `"import"`.
		  op_dict: (Optional.) Deprecated, do not use.
		  producer_op_list: (Optional.) An `OpList` proto with the (possibly stripped)
		    list of `OpDef`s used by the producer of the graph. If provided,
		    unrecognized attrs for ops in `graph_def` that have their default value
		    according to `producer_op_list` will be removed. This will allow some more
		    `GraphDef`s produced by later binaries to be accepted by earlier binaries.
		
		Returns:
		  A list of `Operation` and/or `Tensor` objects from the imported graph,
		  corresponding to the names in `return_elements`,
		  and None if `returns_elements` is None.
		
		Raises:
		  TypeError: If `graph_def` is not a `GraphDef` proto,
		    `input_map` is not a dictionary mapping strings to `Tensor` objects,
		    or `return_elements` is not a list of strings.
		  ValueError: If `input_map`, or `return_elements` contains names that
		    do not appear in `graph_def`, or `graph_def` is not well-formed (e.g.
		    it refers to an unknown tensor).
	**/
	static public function import_graph_def(graph_def:Dynamic, ?input_map:Dynamic, ?return_elements:Dynamic, ?name:Dynamic, ?op_dict:Dynamic, ?producer_op_list:Dynamic):Dynamic;
	static public var int16 : Dynamic;
	static public var int16_ref : Dynamic;
	static public var int32 : Dynamic;
	static public var int32_ref : Dynamic;
	static public var int64 : Dynamic;
	static public var int64_ref : Dynamic;
	static public var int8 : Dynamic;
	static public var int8_ref : Dynamic;
	/**
		Loads a TensorFlow plugin, containing file system implementation. (deprecated)
		
		Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
		Instructions for updating:
		Use `tf.load_library` instead.
		
		Pass `library_filename` to a platform-specific mechanism for dynamically
		loading a library. The rules for determining the exact location of the
		library are platform-specific and are not documented here.
		
		Args:
		  library_filename: Path to the plugin.
		    Relative or absolute filesystem path to a dynamic library file.
		
		Returns:
		  None.
		
		Raises:
		  RuntimeError: when unable to load the library.
	**/
	static public function load_file_system_library(library_filename:Dynamic):Dynamic;
	/**
		Loads a TensorFlow plugin.
		
		"library_location" can be a path to a specific shared object, or a folder.
		If it is a folder, all shared objects that are named "libtfkernel*" will be
		loaded. When the library is loaded, kernels registered in the library via the
		`REGISTER_*` macros are made available in the TensorFlow process.
		
		Args:
		  library_location: Path to the plugin or the folder of plugins.
		    Relative or absolute filesystem path to a dynamic library file or folder.
		
		Returns:
		  None
		
		Raises:
		  OSError: When the file to be loaded is not found.
		  RuntimeError: when unable to load the library.
	**/
	static public function load_library(library_location:Dynamic):Dynamic;
	/**
		Loads a TensorFlow plugin, containing custom ops and kernels.
		
		Pass "library_filename" to a platform-specific mechanism for dynamically
		loading a library. The rules for determining the exact location of the
		library are platform-specific and are not documented here. When the
		library is loaded, ops and kernels registered in the library via the
		`REGISTER_*` macros are made available in the TensorFlow process. Note
		that ops with the same name as an existing op are rejected and not
		registered with the process.
		
		Args:
		  library_filename: Path to the plugin.
		    Relative or absolute filesystem path to a dynamic library file.
		
		Returns:
		  A python module containing the Python wrappers for Ops defined in
		  the plugin.
		
		Raises:
		  RuntimeError: when unable to load the library or get the python wrappers.
	**/
	static public function load_op_library(library_filename:Dynamic):Dynamic;
	/**
		Loads a TensorFlow PluggableDevice plugin.
		
		"library_location" can be a path to a specific shared object, or a folder.
		If it is a folder, all shared objects will be loaded. when the library is
		loaded, devices/kernels registered in the library via StreamExecutor C API
		and Kernel/Op Registration C API are made available in TensorFlow process.
		
		Args:
		  library_location: Path to the plugin or folder of plugins. Relative or
		    absolute filesystem path to a dynamic library file or folder.
		
		Raises:
		  OSError: When the file to be loaded is not found.
		  RuntimeError: when unable to load the library.
	**/
	static public function load_pluggable_device_library(library_location:Dynamic):Dynamic;
	/**
		Create a numpy ndarray from a tensor.
		
		Create a numpy ndarray with the same shape and data as the tensor.
		
		For example:
		
		```python
		# Tensor a has shape (2,3)
		a = tf.constant([[1,2,3],[4,5,6]])
		proto_tensor = tf.make_tensor_proto(a)  # convert `tensor a` to a proto tensor
		tf.make_ndarray(proto_tensor) # output: array([[1, 2, 3],
		#                                              [4, 5, 6]], dtype=int32)
		# output has shape (2,3)
		```
		
		Args:
		  tensor: A TensorProto.
		
		Returns:
		  A numpy array with the tensor contents.
		
		Raises:
		  TypeError: if tensor has unsupported type.
	**/
	static public function make_ndarray(tensor:Dynamic):Dynamic;
	/**
		Create a TensorProto.
		
		In TensorFlow 2.0, representing tensors as protos should no longer be a
		common workflow. That said, this utility function is still useful for
		generating TF Serving request protos:
		
		```python
		  request = tensorflow_serving.apis.predict_pb2.PredictRequest()
		  request.model_spec.name = "my_model"
		  request.model_spec.signature_name = "serving_default"
		  request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
		```
		
		`make_tensor_proto` accepts "values" of a python scalar, a python list, a
		numpy ndarray, or a numpy scalar.
		
		If "values" is a python scalar or a python list, make_tensor_proto
		first convert it to numpy ndarray. If dtype is None, the
		conversion tries its best to infer the right numpy data
		type. Otherwise, the resulting numpy array has a compatible data
		type with the given dtype.
		
		In either case above, the numpy ndarray (either the caller provided
		or the auto-converted) must have the compatible type with dtype.
		
		`make_tensor_proto` then converts the numpy array to a tensor proto.
		
		If "shape" is None, the resulting tensor proto represents the numpy
		array precisely.
		
		Otherwise, "shape" specifies the tensor's shape and the numpy array
		can not have more elements than what "shape" specifies.
		
		Args:
		  values:         Values to put in the TensorProto.
		  dtype:          Optional tensor_pb2 DataType value.
		  shape:          List of integers representing the dimensions of tensor.
		  verify_shape:   Boolean that enables verification of a shape of values.
		  allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
		      broadcasting. Cannot be true when verify_shape is true.
		
		Returns:
		  A `TensorProto`. Depending on the type, it may contain data in the
		  "tensor_content" attribute, which is not directly useful to Python programs.
		  To access the values you should convert the proto back to a numpy ndarray
		  with `tf.make_ndarray(proto)`.
		
		  If `values` is a `TensorProto`, it is immediately returned; `dtype` and
		  `shape` are ignored.
		
		Raises:
		  TypeError:  if unsupported types are provided.
		  ValueError: if arguments have inappropriate values or if verify_shape is
		   True and shape of values is not equals to a shape from the argument.
	**/
	static public function make_tensor_proto(values:Dynamic, ?dtype:Dynamic, ?shape:Dynamic, ?verify_shape:Dynamic, ?allow_broadcast:Dynamic):Dynamic;
	/**
		Internal-only entry point for `name_scope*`.
		
		Internal ops do not use the public API and instead rely on
		`ops.name_scope` regardless of the execution mode. This function
		dispatches to the correct `name_scope*` implementation based on
		the arguments provided and the current mode. Specifically,
		
		* if `values` contains a graph tensor `Graph.name_scope` is used;
		* `name_scope_v1` is used in graph mode;
		* `name_scope_v2` -- in eager mode.
		
		Args:
		  name: The name argument that is passed to the op function.
		  default_name: The default name to use if the `name` argument is `None`.
		  values: The list of `Tensor` arguments that are passed to the op function.
		  skip_on_eager: Indicates to return NullContextmanager if executing eagerly.
		    By default this is True since naming tensors and operations in eager mode
		    have little use and cause unnecessary performance overhead. However, it is
		    important to preserve variable names since they are often useful for
		    debugging and saved models.
		
		Returns:
		  `name_scope*` context manager.
	**/
	static public function name_scope(name:Dynamic, ?default_name:Dynamic, ?values:Dynamic, ?skip_on_eager:Dynamic):Dynamic;
	static public var np_resource : Dynamic;
	/**
		DEPRECATED. Same as name_scope above, just different argument order.
	**/
	static public function op_scope(values:Dynamic, name:Dynamic, ?default_name:Dynamic):Dynamic;
	static public var print_function : Dynamic;
	static public var qint16 : Dynamic;
	static public var qint16_ref : Dynamic;
	static public var qint32 : Dynamic;
	static public var qint32_ref : Dynamic;
	static public var qint8 : Dynamic;
	static public var qint8_ref : Dynamic;
	static public var quint16 : Dynamic;
	static public var quint16_ref : Dynamic;
	static public var quint8 : Dynamic;
	static public var quint8_ref : Dynamic;
	/**
		Loads a TensorFlow FileSystem plugin.
		
		Args:
		  plugin_location: Path to the plugin. Relative or absolute filesystem plugin
		    path to a dynamic library file.
		
		Returns:
		  None
		
		Raises:
		  OSError: When the file to be loaded is not found.
		  RuntimeError: when unable to load the library.
	**/
	static public function register_filesystem_plugin(plugin_location:Dynamic):Dynamic;
	/**
		Registers a function for converting objects of `base_type` to `Tensor`.
		
		The conversion function must have the following signature:
		
		```python
		    def conversion_func(value, dtype=None, name=None, as_ref=False):
		      # ...
		```
		
		It must return a `Tensor` with the given `dtype` if specified. If the
		conversion function creates a new `Tensor`, it should use the given
		`name` if specified. All exceptions will be propagated to the caller.
		
		The conversion function may return `NotImplemented` for some
		inputs. In this case, the conversion process will continue to try
		subsequent conversion functions.
		
		If `as_ref` is true, the function must return a `Tensor` reference,
		such as a `Variable`.
		
		NOTE: The conversion functions will execute in order of priority,
		followed by order of registration. To ensure that a conversion function
		`F` runs before another conversion function `G`, ensure that `F` is
		registered with a smaller priority than `G`.
		
		Args:
		  base_type: The base type or tuple of base types for all objects that
		    `conversion_func` accepts.
		  conversion_func: A function that converts instances of `base_type` to
		    `Tensor`.
		  priority: Optional integer that indicates the priority for applying this
		    conversion function. Conversion functions with smaller priority values run
		    earlier than conversion functions with larger priority values. Defaults to
		    100.
		
		Raises:
		  TypeError: If the arguments do not have the appropriate type.
	**/
	static public function register_tensor_conversion_function(base_type:Dynamic, conversion_func:Dynamic, ?priority:Dynamic):Dynamic;
	/**
		Clears the default graph stack and resets the global default graph.
		
		NOTE: The default graph is a property of the current thread. This
		function applies only to the current thread.  Calling this function while
		a `tf.compat.v1.Session` or `tf.compat.v1.InteractiveSession` is active will
		result in undefined
		behavior. Using any previously created `tf.Operation` or `tf.Tensor` objects
		after calling this function will result in undefined behavior.
		
		@compatibility(TF2)
		`reset_default_graph` does not work with either eager execution or
		`tf.function`, and you should not invoke it directly. To migrate code that
		uses Graph-related functions to TF2, rewrite the code without them. See the
		[migration guide](https://www.tensorflow.org/guide/migrate) for more
		description about the behavior and semantic changes between Tensorflow 1 and
		Tensorflow 2.
		@end_compatibility
		
		Raises:
		  AssertionError: If this function is called within a nested graph.
	**/
	static public function reset_default_graph():Dynamic;
	static public var resource : Dynamic;
	static public var resource_ref : Dynamic;
	/**
		Sets the graph-level random seed for the default graph.
		
		Operations that rely on a random seed actually derive it from two seeds:
		the graph-level and operation-level seeds. This sets the graph-level seed.
		
		Its interactions with operation-level seeds is as follows:
		
		  1. If neither the graph-level nor the operation seed is set:
		    A random seed is used for this op.
		  2. If the graph-level seed is set, but the operation seed is not:
		    The system deterministically picks an operation seed in conjunction with
		    the graph-level seed so that it gets a unique random sequence. Within the
		    same version of tensorflow and user code, this sequence is deterministic.
		    However across different versions, this sequence might change. If the
		    code depends on particular seeds to work, specify both graph-level
		    and operation-level seeds explicitly.
		  3. If the graph-level seed is not set, but the operation seed is set:
		    A default graph-level seed and the specified operation seed are used to
		    determine the random sequence.
		  4. If both the graph-level and the operation seed are set:
		    Both seeds are used in conjunction to determine the random sequence.
		
		To illustrate the user-visible effects, consider these examples:
		
		To generate different sequences across sessions, set neither
		graph-level nor op-level seeds:
		
		```python
		a = tf.random.uniform([1])
		b = tf.random.normal([1])
		
		print("Session 1")
		with tf.compat.v1.Session() as sess1:
		  print(sess1.run(a))  # generates 'A1'
		  print(sess1.run(a))  # generates 'A2'
		  print(sess1.run(b))  # generates 'B1'
		  print(sess1.run(b))  # generates 'B2'
		
		print("Session 2")
		with tf.compat.v1.Session() as sess2:
		  print(sess2.run(a))  # generates 'A3'
		  print(sess2.run(a))  # generates 'A4'
		  print(sess2.run(b))  # generates 'B3'
		  print(sess2.run(b))  # generates 'B4'
		```
		
		To generate the same repeatable sequence for an op across sessions, set the
		seed for the op:
		
		```python
		a = tf.random.uniform([1], seed=1)
		b = tf.random.normal([1])
		
		# Repeatedly running this block with the same graph will generate the same
		# sequence of values for 'a', but different sequences of values for 'b'.
		print("Session 1")
		with tf.compat.v1.Session() as sess1:
		  print(sess1.run(a))  # generates 'A1'
		  print(sess1.run(a))  # generates 'A2'
		  print(sess1.run(b))  # generates 'B1'
		  print(sess1.run(b))  # generates 'B2'
		
		print("Session 2")
		with tf.compat.v1.Session() as sess2:
		  print(sess2.run(a))  # generates 'A1'
		  print(sess2.run(a))  # generates 'A2'
		  print(sess2.run(b))  # generates 'B3'
		  print(sess2.run(b))  # generates 'B4'
		```
		
		To make the random sequences generated by all ops be repeatable across
		sessions, set a graph-level seed:
		
		```python
		tf.compat.v1.random.set_random_seed(1234)
		a = tf.random.uniform([1])
		b = tf.random.normal([1])
		
		# Repeatedly running this block with the same graph will generate the same
		# sequences of 'a' and 'b'.
		print("Session 1")
		with tf.compat.v1.Session() as sess1:
		  print(sess1.run(a))  # generates 'A1'
		  print(sess1.run(a))  # generates 'A2'
		  print(sess1.run(b))  # generates 'B1'
		  print(sess1.run(b))  # generates 'B2'
		
		print("Session 2")
		with tf.compat.v1.Session() as sess2:
		  print(sess2.run(a))  # generates 'A1'
		  print(sess2.run(a))  # generates 'A2'
		  print(sess2.run(b))  # generates 'B1'
		  print(sess2.run(b))  # generates 'B2'
		```
		
		@compatibility(TF2)
		'tf.compat.v1.set_random_seed' is compatible with eager mode. However,
		in eager mode this API will set the global seed instead of the
		graph-level seed of the default graph. In TF2 this API is changed to
		[tf.random.set_seed]
		(https://www.tensorflow.org/api_docs/python/tf/random/set_seed).
		@end_compatibility
		
		Args:
		  seed: integer.
	**/
	static public function set_random_seed(seed:Dynamic):Dynamic;
	static public var string : Dynamic;
	static public var string_ref : Dynamic;
	static public function tf_export(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	static public var uint16 : Dynamic;
	static public var uint16_ref : Dynamic;
	static public var uint32 : Dynamic;
	static public var uint32_ref : Dynamic;
	static public var uint64 : Dynamic;
	static public var uint64_ref : Dynamic;
	static public var uint8 : Dynamic;
	static public var uint8_ref : Dynamic;
	static public var variant : Dynamic;
	static public var variant_ref : Dynamic;
}