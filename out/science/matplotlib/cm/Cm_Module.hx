/* This file is generated, do not edit! */
package matplotlib.cm;
@:pythonImport("matplotlib.cm") extern class Cm_Module {
	static public function Accent(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Accent_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Blues(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Blues_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BrBG(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BrBG_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuPu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuPu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function CMRmap(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function CMRmap_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Dark2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Dark2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function GnBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function GnBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greens(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greens_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greys(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greys_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function OrRd(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function OrRd_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Oranges(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Oranges_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PRGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PRGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Paired(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Paired_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel1(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel1_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PiYG(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PiYG_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBuGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBuGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuOr(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuOr_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuRd(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuRd_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Purples(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Purples_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdGy(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdGy_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdPu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdPu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Reds(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Reds_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set1(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set1_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set3(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set3_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Spectral(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Spectral_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Wistia(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Wistia_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGnBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGnBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrBr(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrBr_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrRd(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrRd_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public var _LUTSIZE : Dynamic;
	static public var __builtin_cmaps : Dynamic;
	static public var __builtins__ : Dynamic;
	static public var __cached__ : Dynamic;
	static public var __doc__ : Dynamic;
	static public var __file__ : Dynamic;
	static public function __getattr__(name:Dynamic):Dynamic;
	static public var __loader__ : Dynamic;
	static public var __name__ : Dynamic;
	static public var __package__ : Dynamic;
	static public var __spec__ : Dynamic;
	static public var _cmap_registry : Dynamic;
	static public function _colormaps():Dynamic;
	/**
		Generate a dict mapping standard colormap names to standard colormaps, as
		well as the reversed colormaps.
	**/
	static public function _gen_cmap_registry():Dynamic;
	static public function afmhot(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function afmhot_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function autumn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function autumn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function binary(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function binary_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bone(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bone_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function brg(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function brg_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bwr(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bwr_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cividis(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cividis_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public var cmap_d : Dynamic;
	static public var cmaps_listed : Dynamic;
	static public function cool(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cool_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function coolwarm(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function coolwarm_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function copper(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function copper_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cubehelix(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cubehelix_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public var datad : Dynamic;
	static public function flag(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function flag_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	/**
		Get a colormap instance, defaulting to rc values if *name* is None.
		
		Colormaps added with :func:`register_cmap` take precedence over
		built-in colormaps.
		
		Notes
		-----
		Currently, this returns the global colormap object, which is deprecated.
		In Matplotlib 3.5, you will no longer be able to modify the global
		colormaps in-place.
		
		Parameters
		----------
		name : `matplotlib.colors.Colormap` or str or None, default: None
		    If a `.Colormap` instance, it will be returned. Otherwise, the name of
		    a colormap known to Matplotlib, which will be resampled by *lut*. The
		    default, None, means :rc:`image.cmap`.
		lut : int or None, default: None
		    If *name* is not already a Colormap instance and *lut* is not None, the
		    colormap will be resampled to have *lut* entries in the lookup table.
	**/
	static public function get_cmap(?name:Dynamic, ?lut:Dynamic):Dynamic;
	static public function gist_earth(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_earth_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_gray(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_gray_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_heat(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_heat_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_ncar(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_ncar_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_rainbow(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_rainbow_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_stern(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_stern_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_yarg(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_yarg_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gray(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gray_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hot(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hot_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hsv(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hsv_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function inferno(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function inferno_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function jet(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function jet_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function magma(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function magma_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function nipy_spectral(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function nipy_spectral_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function ocean(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function ocean_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function pink(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function pink_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function plasma(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function plasma_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function prism(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function prism_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function rainbow(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function rainbow_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	/**
		Add a colormap to the set recognized by :func:`get_cmap`.
		
		Register a new colormap to be accessed by name ::
		
		    LinearSegmentedColormap('swirly', data, lut)
		    register_cmap(cmap=swirly_cmap)
		
		Parameters
		----------
		name : str, optional
		   The name that can be used in :func:`get_cmap` or :rc:`image.cmap`
		
		   If absent, the name will be the :attr:`~matplotlib.colors.Colormap.name`
		   attribute of the *cmap*.
		
		cmap : matplotlib.colors.Colormap
		   Despite being the second argument and having a default value, this
		   is a required argument.
		
		override_builtin : bool
		
		    Allow built-in colormaps to be overridden by a user-supplied
		    colormap.
		
		    Please do not use this unless you are sure you need it.
		
		Notes
		-----
		Registering a colormap stores a reference to the colormap object
		which can currently be modified and inadvertently change the global
		colormap state. This behavior is deprecated and in Matplotlib 3.5
		the registered colormap will be immutable.
	**/
	static public function register_cmap(?name:Dynamic, ?cmap:Dynamic, ?override_builtin:Dynamic):Dynamic;
	static public function seismic(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function seismic_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function spring(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function spring_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function summer(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function summer_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab10(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab10_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20b(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20b_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20c(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20c_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function terrain(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function terrain_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function turbo(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function turbo_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight_shifted(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight_shifted_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	/**
		Remove a colormap recognized by :func:`get_cmap`.
		
		You may not remove built-in colormaps.
		
		If the named colormap is not registered, returns with no error, raises
		if you try to de-register a default colormap.
		
		.. warning ::
		
		  Colormap names are currently a shared namespace that may be used
		  by multiple packages. Use `unregister_cmap` only if you know you
		  have registered that name before. In particular, do not
		  unregister just in case to clean the name before registering a
		  new colormap.
		
		Parameters
		----------
		name : str
		    The name of the colormap to be un-registered
		
		Returns
		-------
		ColorMap or None
		    If the colormap was registered, return it if not return `None`
		
		Raises
		------
		ValueError
		   If you try to de-register a default built-in colormap.
	**/
	static public function unregister_cmap(name:Dynamic):Dynamic;
	static public function viridis(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function viridis_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function winter(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function winter_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
}