/* This file is generated, do not edit! */
package matplotlib.streamplot;
@:pythonImport("matplotlib.streamplot") extern class Streamplot_Module {
	static public var __all__ : Dynamic;
	static public var __builtins__ : Dynamic;
	static public var __cached__ : Dynamic;
	static public var __doc__ : Dynamic;
	static public var __file__ : Dynamic;
	static public var __loader__ : Dynamic;
	static public var __name__ : Dynamic;
	static public var __package__ : Dynamic;
	static public var __spec__ : Dynamic;
	/**
		Simple Euler integration step that extends streamline to boundary.
	**/
	static public function _euler_step(xyf_traj:Dynamic, dmap:Dynamic, f:Dynamic):Dynamic;
	/**
		Yield starting points for streamlines.
		
		Trying points on the boundary first gives higher quality streamlines.
		This algorithm starts with a point on the mask corner and spirals inward.
		This algorithm is inefficient, but fast compared to rest of streamplot.
	**/
	static public function _gen_starting_points(shape:Dynamic):Dynamic;
	static public function _get_integrator(u:Dynamic, v:Dynamic, dmap:Dynamic, minlength:Dynamic, maxlength:Dynamic, integration_direction:Dynamic):Dynamic;
	/**
		2nd-order Runge-Kutta algorithm with adaptive step size.
		
		This method is also referred to as the improved Euler's method, or Heun's
		method. This method is favored over higher-order methods because:
		
		1. To get decent looking trajectories and to sample every mask cell
		   on the trajectory we need a small timestep, so a lower order
		   solver doesn't hurt us unless the data is *very* high resolution.
		   In fact, for cases where the user inputs
		   data smaller or of similar grid size to the mask grid, the higher
		   order corrections are negligible because of the very fast linear
		   interpolation used in `interpgrid`.
		
		2. For high resolution input data (i.e. beyond the mask
		   resolution), we must reduce the timestep. Therefore, an adaptive
		   timestep is more suited to the problem as this would be very hard
		   to judge automatically otherwise.
		
		This integrator is about 1.5 - 2x as fast as RK4 and RK45 solvers (using
		similar Python implementations) in most setups.
	**/
	static public function _integrate_rk12(x0:Dynamic, y0:Dynamic, dmap:Dynamic, f:Dynamic, maxlength:Dynamic):Dynamic;
	/**
		[*Deprecated*] 
		
		Notes
		-----
		.. deprecated:: 3.5
		   \ 
	**/
	static public function get_integrator(u:Dynamic, v:Dynamic, dmap:Dynamic, minlength:Dynamic, maxlength:Dynamic, integration_direction:Dynamic):Dynamic;
	/**
		Fast 2D, linear interpolation on an integer grid
	**/
	static public function interpgrid(a:Dynamic, xi:Dynamic, yi:Dynamic):Dynamic;
	/**
		Draw streamlines of a vector flow.
		
		Parameters
		----------
		x, y : 1D/2D arrays
		    Evenly spaced strictly increasing arrays to make a grid.  If 2D, all
		    rows of *x* must be equal and all columns of *y* must be equal; i.e.,
		    they must be as if generated by ``np.meshgrid(x_1d, y_1d)``.
		u, v : 2D arrays
		    *x* and *y*-velocities. The number of rows and columns must match
		    the length of *y* and *x*, respectively.
		density : float or (float, float)
		    Controls the closeness of streamlines. When ``density = 1``, the domain
		    is divided into a 30x30 grid. *density* linearly scales this grid.
		    Each cell in the grid can have, at most, one traversing streamline.
		    For different densities in each direction, use a tuple
		    (density_x, density_y).
		linewidth : float or 2D array
		    The width of the stream lines. With a 2D array the line width can be
		    varied across the grid. The array must have the same shape as *u*
		    and *v*.
		color : color or 2D array
		    The streamline color. If given an array, its values are converted to
		    colors using *cmap* and *norm*.  The array must have the same shape
		    as *u* and *v*.
		cmap : `~matplotlib.colors.Colormap`
		    Colormap used to plot streamlines and arrows. This is only used if
		    *color* is an array.
		norm : `~matplotlib.colors.Normalize`
		    Normalize object used to scale luminance data to 0, 1. If ``None``,
		    stretch (min, max) to (0, 1). This is only used if *color* is an array.
		arrowsize : float
		    Scaling factor for the arrow size.
		arrowstyle : str
		    Arrow style specification.
		    See `~matplotlib.patches.FancyArrowPatch`.
		minlength : float
		    Minimum length of streamline in axes coordinates.
		start_points : Nx2 array
		    Coordinates of starting points for the streamlines in data coordinates
		    (the same coordinates as the *x* and *y* arrays).
		zorder : int
		    The zorder of the stream lines and arrows.
		    Artists with lower zorder values are drawn first.
		maxlength : float
		    Maximum length of streamline in axes coordinates.
		integration_direction : {'forward', 'backward', 'both'}, default: 'both'
		    Integrate the streamline in forward, backward or both directions.
		data : indexable object, optional
		    DATA_PARAMETER_PLACEHOLDER
		
		Returns
		-------
		StreamplotSet
		    Container object with attributes
		
		    - ``lines``: `.LineCollection` of streamlines
		
		    - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch`
		      objects representing the arrows half-way along stream lines.
		
		    This container will probably change in the future to allow changes
		    to the colormap, alpha, etc. for both lines and arrows, but these
		    changes should be backward compatible.
	**/
	static public function streamplot(axes:Dynamic, x:Dynamic, y:Dynamic, u:Dynamic, v:Dynamic, ?density:Dynamic, ?linewidth:Dynamic, ?color:Dynamic, ?cmap:Dynamic, ?norm:Dynamic, ?arrowsize:Dynamic, ?arrowstyle:Dynamic, ?minlength:Dynamic, ?transform:Dynamic, ?zorder:Dynamic, ?start_points:Dynamic, ?maxlength:Dynamic, ?integration_direction:Dynamic):Dynamic;
}